# SitemapのETag/TTL最適化: シナリオ

## シナリオ1: 更新なしアクセスで304を返す

- 前提: `contents_revisions` の最新リビジョンが X、サイトマップETagが `W/"X"` として運用中。
- 事象: クローラが `If-None-Match: W/"X"` を付与して `/sitemap.xml` にアクセス。
- 期待:
  - アプリは D1 から最新リビジョンを取得し、ETagを `W/"X"` と比較。
  - 一致時は `304 Not Modified` を返し、本文は送らない。
  - `Cache-Control` はヒットに最適化された値（例: `public, max-age=300, s-maxage=86400, stale-while-revalidate=60`）。

## シナリオ2: 更新直後のアクセスで200を返す（新ETag）

- 前提: 直前のデプロイ/投稿により `contents_revisions` が X→Y に更新。
- 事象: クローラが旧ETag `If-None-Match: W/"X"` でアクセス。
- 期待:
  - 最新リビジョンYに基づき、新しいETag `W/"Y"` を生成。
  - `200 OK` とサイトマップ本体を返却、`ETag: W/"Y"` を付与。
  - 直後はTTLを短めに（例: `s-maxage=300`）設定し、再クロールを促進。

## シナリオ3: 長期間更新なしでTTLを延ばす

- 前提: 30日間更新なし。
- 事象: エッジやクローラから定期アクセス。
- 期待:
  - 更新頻度に応じたポリシーで `s-maxage` を最大（例: 7日〜30日）へ自動延長。
  - 条件付きリクエストで304を継続的に返し、トラフィックを最小化。

## シナリオ4: サイトマップ分割時の部分更新

- 前提: サイトマップがインデックス+複数子サイトマップで構成、子ごとに対象コンテンツ領域が分割されている。
- 事象: ある領域だけが更新。
- 期待:
  - 子サイトマップ単位でETag/Last-Modifiedを算出。
  - 影響のない子サイトマップは304が継続し、影響のある子のみ200で更新。

## シナリオ5: 異常系（D1一時障害）

- 前提: D1参照が一時的に失敗。
- 事象: `/sitemap.xml` へアクセス。
- 期待:
  - 直近成功時のメタ（ETag/Last-Modified）をKV等にキャッシュしていればフォールバック。
  - 不可能な場合は `5xx` を返しつつ、過剰な情報露出はしない。
